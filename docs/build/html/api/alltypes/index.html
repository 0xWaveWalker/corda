<HTML>
<HEAD>
<title>alltypes - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<h3>All Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="../core.utilities/-a-n-s-i-progress-renderer/index.html">core.utilities.ANSIProgressRenderer</a></td>
<td>
<p>Knows how to render a <a href="../core.utilities/-progress-tracker/index.html">ProgressTracker</a> to the terminal using coloured, emoji-fied output. Useful when writing small
command line tools, demos, tests etc. Just set the <a href="../core.utilities/-a-n-s-i-progress-renderer/progress-tracker.html">progressTracker</a> field and it will go ahead and start drawing
if the terminal supports it. Otherwise it just prints out the name of the step whenever it changes.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node/-abstract-node/index.html">core.node.AbstractNode</a></td>
<td>
<p>A base node implementation that can be customised either for production (with real implementations that do real
I/O), or a mock implementation suitable for unit test environments.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-all-possible-recipients.html">core.messaging.AllPossibleRecipients</a></td>
<td>
<p>A special base class for the set of all possible recipients, without having to identify who they all are.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-amount/index.html">core.Amount</a></td>
<td>
<p>Amount represents a positive quantity of currency, measured in pennies, which are the smallest representable units.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-artemis-messaging-service/index.html">core.node.services.ArtemisMessagingService</a></td>
<td>
<p>This class implements the <a href="../core.messaging/-messaging-service/index.html">MessagingService</a> API using Apache Artemis, the successor to their ActiveMQ product.
Artemis is a message queue broker and here, we embed the entire server inside our own process. Nodes communicate
with each other using (by default) an Artemis specific protocol, but it supports other protocols like AQMP/1.0
as well.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-attachment/index.html">core.Attachment</a></td>
<td>
<p>An attachment is a ZIP (or an optionally signed JAR) that contains one or more files. Attachments are meant to
contain public static data which can be referenced from transactions and utilised from contracts. Good examples
of how attachments are meant to be used include:</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.servlets/-attachment-download-servlet/index.html">core.node.servlets.AttachmentDownloadServlet</a></td>
<td>
<p>Allows the node administrator to either download full attachment zips, or individual files within those zips.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-attachment-storage/index.html">core.node.services.AttachmentStorage</a></td>
<td>
<p>An attachment store records potentially large binary objects, identified by their hash. Note that attachments are
immutable and can never be erased once inserted</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.servlets/-attachment-upload-servlet/index.html">core.node.servlets.AttachmentUploadServlet</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-authenticated-object/index.html">core.AuthenticatedObject</a></td>
<td>
<p>Wraps an object that was signed by a public key, which may be a well known/recognised institutional key.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.utilities/-brief-log-formatter/index.html">core.utilities.BriefLogFormatter</a></td>
<td>
<p>A Java logging formatter that writes more compact output than the default.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/kotlin.-byte-array/index.html">kotlin.ByteArray</a> (extensions in package core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.serialization/kotlin.-byte-array/index.html">kotlin.ByteArray</a> (extensions in package core.serialization)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../contracts/-cash/index.html">contracts.Cash</a></td>
<td>
<p>A cash transaction may split and merge money represented by a set of (issuer, depositRef) pairs, across multiple
input and output states. Imagine a Bitcoin transaction but in which all UTXOs had a colour
(a blend of issuer+depositRef) and you couldnt merge outputs of two colours together, but you COULD put them in
the same transaction.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-command/index.html">core.Command</a></td>
<td>
<p>Command data/content plus pubkey pair: the signature is stored at the end of the serialized bytes</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-command-data.html">core.CommandData</a></td>
<td>
<p>Marker interface for classes that represent commands</p>
</td>
</tr>
<tr>
<td>
<a href="../contracts/-commercial-paper/index.html">contracts.CommercialPaper</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.node/-configuration-exception/index.html">core.node.ConfigurationException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-contract/index.html">core.Contract</a></td>
<td>
<p>Implemented by a program that implements business logic on the shared ledger. All participants run this code for
every <a href="../core/-ledger-transaction/index.html">LedgerTransaction</a> they see on the network, for every input and output state. All contracts must accept the
transaction for it to be accepted: failure of any aborts the entire thing. The time is taken from a trusted
timestamp attached to the transaction itself i.e. it is NOT necessarily the current time.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-contract-factory/index.html">core.ContractFactory</a></td>
<td>
<p>A contract factory knows how to lazily load and instantiate contract objects.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-contract-state/index.html">core.ContractState</a></td>
<td>
<p>A contract state (or just "state") contains opaque data used by a contract program. It can be thought of as a disk
file that the program can use to persist data across transactions. States are immutable: once created they are never
updated, instead, any changes must generate a new successor state.</p>
</td>
</tr>
<tr>
<td>
<a href="../contracts/-crowd-fund/index.html">contracts.CrowdFund</a></td>
<td>
<p>This is a basic crowd funding contract. It allows a party to create a funding opportunity, then for others to
pledge during the funding period , and then for the party to either accept the funding (if the target has been reached)
return the funds to the pledge-makers (if the target has not been reached).</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-data-vending-service/index.html">core.node.services.DataVendingService</a></td>
<td>
<p>This class sets up network message handlers for requests from peers for data keyed by hash. It is a piece of simple
glue that sits between the network layer and the database layer.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/-digital-signature/index.html">core.crypto.DigitalSignature</a></td>
<td>
<p>A wrapper around a digital signature. The covering field is a generic tag usable by whatever is interpreting the
signature. It isnt used currently, but experience from Bitcoin suggests such a feature is useful, especially when
building partially signed transactions.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/kotlin.-double/index.html">kotlin.Double</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../contracts/-dummy-contract/index.html">contracts.DummyContract</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/-dummy-public-key/index.html">core.crypto.DummyPublicKey</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-dummy-timestamping-authority/index.html">core.node.services.DummyTimestampingAuthority</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-e2-e-test-key-management-service/index.html">core.node.services.E2ETestKeyManagementService</a></td>
<td>
<p>A simple in-memory KMS that doesnt bother saving keys to disk. A real implementation would:</p>
</td>
</tr>
<tr>
<td>
<a href="../core.utilities/-emoji/index.html">core.utilities.Emoji</a></td>
<td>
<p>A simple wrapper class that contains icons and support for printing them only when were connected to a terminal.</p>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-fetch-attachments-protocol/index.html">protocols.FetchAttachmentsProtocol</a></td>
<td>
<p>Given a set of hashes either loads from from local storage  or requests them from the other peer. Downloaded
attachments are saved to local storage automatically.</p>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-fetch-data-protocol/index.html">protocols.FetchDataProtocol</a></td>
<td>
<p>An abstract protocol for fetching typed data from a remote peer.</p>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-fetch-transactions-protocol/index.html">protocols.FetchTransactionsProtocol</a></td>
<td>
<p>Given a set of tx hashes (IDs), either loads them from local disk or asks the remote peer to provide them.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-fixed-identity-service/index.html">core.node.services.FixedIdentityService</a></td>
<td>
<p>Scaffolding: a dummy identity service that just expects to have identities loaded off disk or found elsewhere.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-identity-service/index.html">core.node.services.IdentityService</a></td>
<td>
<p>An identity service maintains an bidirectional map of <a href="../core/-party/index.html">Party</a>s to their associated public keys and thus supports
lookup of a party given its key. This is obviously very incomplete and does not reflect everything a real identity
service would provide.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.serialization/-immutable-class-serializer/index.html">core.serialization.ImmutableClassSerializer</a></td>
<td>
<p>Serializes properties and deserializes by using the constructor. This assumes that all backed properties are
set via the constructor and the class is immutable.</p>
</td>
</tr>
<tr>
<td>
<a href="../contracts/-insufficient-balance-exception/index.html">contracts.InsufficientBalanceException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/kotlin.-int/index.html">kotlin.Int</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../contracts/kotlin.collections.-iterable/index.html">kotlin.collections.Iterable</a> (extensions in package contracts)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-key-management-service/index.html">core.node.services.KeyManagementService</a></td>
<td>
<p>The KMS is responsible for storing and using private keys to sign things. An implementation of this may, for example,
call out to a hardware security module that enforces various auditing and frequency-of-use requirements.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/java.security.-key-pair/index.html">java.security.KeyPair</a> (extensions in package core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-ledger-transaction/index.html">core.LedgerTransaction</a></td>
<td>
<p>A LedgerTransaction wraps the data needed to calculate one or more successor states from a set of input states.
It is the first step after extraction from a WireTransaction. The signatures at this point have been lined up
with the commands from the wire, and verified/looked up.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-legally-identifiable-node/index.html">core.messaging.LegallyIdentifiableNode</a></td>
<td>
<p>Info about a network node that has is operated by some sort of verified identity.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/kotlin.collections.-list/index.html">kotlin.collections.List</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-message/index.html">core.messaging.Message</a></td>
<td>
<p>A message is defined, at this level, to be a (topic, timestamp, byte arrays) triple, where the topic is a string in
Java-style reverse dns form, with "platform." being a prefix reserved by the platform for its own use. Vendor
specific messages can be defined, but use your domain name as the prefix e.g. "uk.co.bigbank.messages.SomeMessage".</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-message-handler-registration.html">core.messaging.MessageHandlerRegistration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-message-recipient-group.html">core.messaging.MessageRecipientGroup</a></td>
<td>
<p>A base class for a set of recipients specifically identified by the sender.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-message-recipients.html">core.messaging.MessageRecipients</a></td>
<td>
<p>The interface for a group of message recipients (which may contain only one recipient)</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-messaging-service/index.html">core.messaging.MessagingService</a></td>
<td>
<p>A <a href="../core.messaging/-messaging-service/index.html">MessagingService</a> sits at the boundary between a message routing / networking layer and the core platform code.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-messaging-service-builder/index.html">core.messaging.MessagingServiceBuilder</a></td>
<td>
<p>This class lets you start up a <a href="../core.messaging/-messaging-service/index.html">MessagingService</a>. Its purpose is to stop you from getting access to the methods
on the messaging service interface until you have successfully started up the system. One of these objects should
be the only way to obtain a reference to a <a href="../core.messaging/-messaging-service/index.html">MessagingService</a>. Startup may be a slow process: some implementations
may let you cast the returned future to an object that lets you get status info.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-mock-network-map/index.html">core.messaging.MockNetworkMap</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-named-by-hash/index.html">core.NamedByHash</a></td>
<td>
<p>Implemented by anything that can be named by a secure hash value (e.g. transactions, attachments).</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-network-map/index.html">core.messaging.NetworkMap</a></td>
<td>
<p>A network map contains lists of nodes on the network along with information about their identity keys, services
they provide and host names or IP addresses where they can be connected to. A reasonable architecture for the
network map service might be one like the Tor directory authorities, where several nodes linked by RAFT or Paxos
elect a leader and that leader distributes signed documents describing the network layout. Those documents can
then be cached by every node and thus a network map can be retrieved given only a single successful peer connection.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node/-node/index.html">core.node.Node</a></td>
<td>
<p>A Node manages a standalone server that takes part in the P2P network. It creates the services found in <a href="#">ServiceHub</a>,
loads important data off disk and starts listening for connections.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-node-attachment-service/index.html">core.node.services.NodeAttachmentService</a></td>
<td>
<p>Stores attachments in the specified local directory, which must exist. Doesnt allow new attachments to be uploaded.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node/-node-configuration/index.html">core.node.NodeConfiguration</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.node/-node-configuration-from-properties/index.html">core.node.NodeConfigurationFromProperties</a></td>
<td>
<p>A simple wrapper around a plain old Java .properties file. The keys have the same name as in the source code.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-node-timestamper-service/index.html">core.node.services.NodeTimestamperService</a></td>
<td>
<p>This class implements the server side of the timestamping protocol, using the local clock. A future version might
add features like checking against other NTP servers to make sure the clock hasnt drifted by too much.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-node-wallet-service/index.html">core.node.services.NodeWalletService</a></td>
<td>
<p>This class implements a simple, in memory wallet that tracks states that are owned by us, and also has a convenience
method to auto-generate some self-issued cash states that can be used for test trading. A real wallet would persist
states relevant to us into a database and once such a wallet is implemented, this scaffolding can be removed.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/-null-public-key/index.html">core.crypto.NullPublicKey</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.serialization/-opaque-bytes/index.html">core.serialization.OpaqueBytes</a></td>
<td>
<p>A simple class that wraps a byte array and makes the equals/hashCode/toString methods work as you actually expect.
In an ideal JVM this would be a value type and be completely overhead free. Project Valhalla is adding such
functionality to Java, but it wont arrive for a few years yet</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-ownable-state/index.html">core.OwnableState</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-party/index.html">core.Party</a></td>
<td>
<p>A <a href="../core/-party/index.html">Party</a> is well known (name, pubkey) pair. In a real system this would probably be an X.509 certificate.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-party-reference/index.html">core.PartyReference</a></td>
<td>
<p>Reference to something being stored or issued by a party e.g. in a vault or (more likely) on their normal
ledger. The reference is intended to be encrypted so its meaningless to anyone other than the party.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/java.nio.file.-path/index.html">java.nio.file.Path</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/java.security.-private-key/index.html">java.security.PrivateKey</a> (extensions in package core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.utilities/-progress-tracker/index.html">core.utilities.ProgressTracker</a></td>
<td>
<p>A progress tracker helps surface information about the progress of an operation to a user interface or API of some
kind. It lets you define a set of <emph>steps</emph> that represent an operation. A step is represented by an object (typically
a singleton).</p>
</td>
</tr>
<tr>
<td>
<a href="../core.protocols/-protocol-logic/index.html">core.protocols.ProtocolLogic</a></td>
<td>
<p>A sub-class of <a href="../core.protocols/-protocol-logic/index.html">ProtocolLogic</a> implements a protocol flow using direct, straight line blocking code. Thus you
can write complex protocol logic in an ordinary fashion, without having to think about callbacks, restarting after
a node crash, how many instances of your protocol there are running and so on.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.protocols/-protocol-state-machine/index.html">core.protocols.ProtocolStateMachine</a></td>
<td>
<p>A ProtocolStateMachine instance is a suspendable fiber that delegates all actual logic to a <a href="../core.protocols/-protocol-logic/index.html">ProtocolLogic</a> instance.
For any given flow there is only one PSM, even if that protocol invokes subprotocols.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/java.security.-public-key/index.html">java.security.PublicKey</a> (extensions in package core.crypto)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-requirements/index.html">core.Requirements</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-resolve-transactions-protocol/index.html">protocols.ResolveTransactionsProtocol</a></td>
<td>
<p>This protocol fetches each transaction identified by the given hashes from either disk or network, along with all
their dependencies, and verifies them together using a single <a href="../core/-transaction-group/index.html">TransactionGroup</a>. If no exception is thrown, then
all the transactions have been successfully verified and inserted into the local database.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.crypto/-secure-hash/index.html">core.crypto.SecureHash</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.serialization/-serialized-bytes/index.html">core.serialization.SerializedBytes</a></td>
<td>
<p>A type safe wrapper around a byte array that contains a serialised object. You can call <a href="../core.serialization/kotlin.-byte-array/deserialize.html">SerializedBytes.deserialize</a>
to get the original object back.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-service-hub/index.html">core.node.services.ServiceHub</a></td>
<td>
<p>A service hub simply vends references to the other services a node has. Some of those services may be missing or
mocked out. This class is useful to pass to chunks of pluggable code that might have need of many different kinds of
functionality and you dont want to hard-code which types in the interface.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-signed-transaction/index.html">core.SignedTransaction</a></td>
<td>
<p>Container for a <a href="../core/-wire-transaction/index.html">WireTransaction</a> and attached signatures.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-single-message-recipient.html">core.messaging.SingleMessageRecipient</a></td>
<td>
<p>A base class for the case of point-to-point messages</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-state-and-ref/index.html">core.StateAndRef</a></td>
<td>
<p>A StateAndRef is simply a (state, ref) pair. For instance, a wallet (which holds available assets) contains these.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-state-machine-manager/index.html">core.messaging.StateMachineManager</a></td>
<td>
<p>A StateMachineManager is responsible for coordination and persistence of multiple <a href="../core.protocols/-protocol-state-machine/index.html">ProtocolStateMachine</a> objects.
Each such object represents an instantiation of a (two-party) protocol that has reached a particular point.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-state-ref/index.html">core.StateRef</a></td>
<td>
<p>A stateref is a pointer (reference) to a state, this is an equivalent of an "outpoint" in Bitcoin. It records which
transaction defined the state and where in that transaction it was.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-storage-service/index.html">core.node.services.StorageService</a></td>
<td>
<p>A sketch of an interface to a simple key/value storage system. Intended for persistence of simple blobs like
transactions, serialised protocol state machines and so on. Again, this isnt intended to imply lack of SQL or
anything like that, this interface is only big enough to support the prototyping work.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/kotlin.-string/index.html">kotlin.String</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/java.time.temporal.-temporal/index.html">java.time.temporal.Temporal</a> (extensions in package core)</td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-thread-box/index.html">core.ThreadBox</a></td>
<td>
<p>A threadbox is a simple utility that makes it harder to forget to take a lock before accessing some shared state.
Simply define a private class to hold the data that must be grouped under the same lock, and then pass the only
instance to the ThreadBox constructor. You can now use the <a href="../core/-thread-box/locked.html">locked</a> method with a lambda to take the lock in a
way that ensures itll be released if theres an exception.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-timestamp-command/index.html">core.TimestampCommand</a></td>
<td>
<p>If present in a transaction, contains a time that was verified by the timestamping authority/authorities whose
public keys are identified in the containing <a href="../core/-command/index.html">Command</a> object. The true time must be between (after, before)</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-timestamper-service/index.html">core.node.services.TimestamperService</a></td>
<td>
<p>Simple interface (for testing) to an abstract timestamping service. Note that this is not "timestamping" in the
blockchain sense of a total ordering of transactions, but rather, a signature from a well known/trusted timestamping
service over a transaction that indicates the timestamp in it is accurate. Such a signature may not always be
necessary: if there are multiple parties involved in a transaction then they can cross-check the timestamp
themselves.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-timestamping-error/index.html">core.node.services.TimestampingError</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-timestamping-protocol/index.html">protocols.TimestampingProtocol</a></td>
<td>
<p>The TimestampingProtocol class is the client code that talks to a <a href="../core.node.services/-node-timestamper-service/index.html">NodeTimestamperService</a> on some remote node. It is a
<a href="../core.protocols/-protocol-logic/index.html">ProtocolLogic</a>, meaning it can either be a sub-protocol of some other protocol, or be driven independently.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.messaging/-topic-string-validator/index.html">core.messaging.TopicStringValidator</a></td>
<td>
<p>A singleton thats useful for validating topic strings</p>
</td>
</tr>
<tr>
<td>
<a href="../demos/-trader-demo-protocol-buyer/index.html">demos.TraderDemoProtocolBuyer</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../demos/-trader-demo-protocol-seller/index.html">demos.TraderDemoProtocolSeller</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-builder/index.html">core.TransactionBuilder</a></td>
<td>
<p>A mutable transaction thats in the process of being built, before all signatures are present.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-conflict-exception/index.html">core.TransactionConflictException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-for-verification/index.html">core.TransactionForVerification</a></td>
<td>
<p>A transaction in fully resolved and sig-checked form, ready for passing as input to a verification function.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-graph-search/index.html">core.TransactionGraphSearch</a></td>
<td>
<p>Given a map of transaction id to <a href="../core/-signed-transaction/index.html">SignedTransaction</a>, performs a breadth first search of the dependency graph from
the starting point down in order to find transactions that match the given query criteria.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-group/index.html">core.TransactionGroup</a></td>
<td>
<p>A TransactionGroup defines a directed acyclic graph of transactions that can be resolved with each other and then
verified. Successful verification does not imply the non-existence of other conflicting transactions: simply that
this subgraph does not contain conflicts and is accepted by the involved contracts.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-resolution-exception/index.html">core.TransactionResolutionException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core/-transaction-verification-exception/index.html">core.TransactionVerificationException</a></td>
<td>
<p>Thrown if a verification fails due to a contract rejection.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-transient-property/index.html">core.TransientProperty</a></td>
<td>
<p>A simple wrapper that enables the use of Kotlins "val x by TransientProperty { ... }" syntax. Such a property
will not be serialized to disk, and if its missing (or the first time its accessed), the initializer will be
used to set it up. Note that the initializer will be called with the TransientProperty object locked.</p>
</td>
</tr>
<tr>
<td>
<a href="../protocols/-two-party-trade-protocol/index.html">protocols.TwoPartyTradeProtocol</a></td>
<td>
<p>This asset trading protocol implements a "delivery vs payment" type swap. It has two parties (B and S for buyer
and seller) and the following steps:</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-type-only-command-data/index.html">core.TypeOnlyCommandData</a></td>
<td>
<p>Commands that inherit from this are intended to have no data items: its only their presence that matters.</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-unknown-contract-exception/index.html">core.UnknownContractException</a></td>
<td>
</td>
</tr>
<tr>
<td>
<a href="../core.utilities/-untrustworthy-data/index.html">core.utilities.UntrustworthyData</a></td>
<td>
<p>A small utility to approximate taint tracking: if a method gives you back one of these, it means the data came from
a remote source that may be incentivised to pass us junk that violates basic assumptions and thus must be checked
first. The wrapper helps you to avoid forgetting this vital step. Things you might want to check are:</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-wallet/index.html">core.node.services.Wallet</a></td>
<td>
<p>A wallet (name may be temporary) wraps a set of states that are useful for us to keep track of, for instance,
because we own them. This class represents an immutable, stable state of a wallet: it is guaranteed not to
change out from underneath you, even though the canonical currently-best-known wallet may change as we learn
about new transactions from our peers and generate new transactions that consume states ourselves.</p>
</td>
</tr>
<tr>
<td>
<a href="../core.node.services/-wallet-service/index.html">core.node.services.WalletService</a></td>
<td>
<p>A <a href="../core.node.services/-wallet-service/index.html">WalletService</a> is responsible for securely and safely persisting the current state of a wallet to storage. The
wallet service vends immutable snapshots of the current wallet for working with: if you build a transaction based
on a wallet that isnt current, be aware that it may end up being invalid if the states that were used have been
consumed by someone else first</p>
</td>
</tr>
<tr>
<td>
<a href="../core/-wire-transaction/index.html">core.WireTransaction</a></td>
<td>
<p>Transaction ready for serialisation, without any signatures attached.</p>
</td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
