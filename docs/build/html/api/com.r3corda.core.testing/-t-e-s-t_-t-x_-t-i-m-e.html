<HTML>
<HEAD>
<title>TEST_TX_TIME - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<a href="index.html">com.r3corda.core.testing</a>&nbsp;/&nbsp;<a href=".">TEST_TX_TIME</a><br/>
<br/>
<h1>TEST_TX_TIME</h1>
<a name="com.r3corda.core.testing$TEST_TX_TIME"></a>
<code><span class="keyword">val </span><span class="identifier">TEST_TX_TIME</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/6/docs/api/java/time/Instant.html"><span class="identifier">Instant</span></a></code><br/>
JAVA INTEROP<p>Please keep the following points in mind when extending the Kotlin DSL:</p>
<ul><li><p>Annotate functions with Kotlin defaults with @JvmOverloads. This produces the relevant overloads for Java.</p>
</li><li><p>Void closures in arguments are inconvenient in Java, use overloading to define non-closure variants as well.</p>
</li><li><p>Top-level vals are trickier. <emph>DO NOT USE@JvmField at the top level</emph> Its surprisingly easy to
introduce a static init cycle because of the way Kotlin compiles top-level things, which can cause
non-deterministic behaviour, including your field not being initialized at all Instead opt for a proper Kotlin
val either with a custom @JvmStatic get() or a lazy delegate if the initialiser has side-effects. See examples below.</p>
</li><li><p>Infix functions work as regular ones from Java, but symbols with spaces in them dont Define a camelCase variant
as well.</p>
</li><li><p>varargs are exposed as array types in Java. Define overloads for common cases.</p>
</li><li><p>The Int.DOLLARS syntax doesnt work from Java.  Use the DOLLARS(int) function instead.</p>
</li></ul><br/>
<br/>
<br/>
<br/>
</BODY>
</HTML>
