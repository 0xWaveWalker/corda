<HTML>
<HEAD>
<title>com.r3corda.protocols - </title>
<link rel="stylesheet" href="../style.css">
</HEAD>
<BODY>
<a href=".">com.r3corda.protocols</a><br/>
<br/>
<h2>Package com.r3corda.protocols</h2>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="-abstract-state-replacement-protocol/index.html">AbstractStateReplacementProtocol</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">AbstractStateReplacementProtocol</span><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span></code><p>Abstract protocol to be used for replacing one state with another, for example when changing the notary of a state.
Notably this requires a one to one replacement of states, states cannot be split, merged or issued as part of these
protocols.</p>
</td>
</tr>
<tr>
<td>
<a href="-broadcast-transaction-protocol/index.html">BroadcastTransactionProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">BroadcastTransactionProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">Unit</span><span class="symbol">&gt;</span></code><p>Notify all involved parties about a transaction, including storing a copy. Normally this would be called via
<a href="-finality-protocol/index.html">FinalityProtocol</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="-direct-request-message/index.html">DirectRequestMessage</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">DirectRequestMessage</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-service-request-message/index.html"><span class="identifier">ServiceRequestMessage</span></a></code><p>A message which specifies reply destination as a specific endpoint such as a monitoring client. This is of particular
use where we want to address a specific endpoint, not necessarily a specific user (for example if the same user logs
in on two machines, we want to consistently deliver messages as part of a session, to the same machine the session
started on).</p>
</td>
</tr>
<tr>
<td>
<a href="-fetch-attachments-protocol/index.html">FetchAttachmentsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FetchAttachmentsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-fetch-data-protocol/index.html"><span class="identifier">FetchDataProtocol</span></a><span class="symbol">&lt;</span><a href="../com.r3corda.core.contracts/-attachment/index.html"><span class="identifier">Attachment</span></a><span class="symbol">,</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">&gt;</span></code><p>Given a set of hashes either loads from from local storage  or requests them from the other peer. Downloaded
attachments are saved to local storage automatically.</p>
</td>
</tr>
<tr>
<td>
<a href="-fetch-data-protocol/index.html">FetchDataProtocol</a></td>
<td>
<code><span class="keyword">abstract</span> <span class="keyword">class </span><span class="identifier">FetchDataProtocol</span><span class="symbol">&lt;</span><span class="identifier">T</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.contracts/-named-by-hash/index.html"><span class="identifier">NamedByHash</span></a><span class="symbol">, </span><span class="keyword">in</span>&nbsp;<span class="identifier">W</span>&nbsp;<span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">&gt;</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><a href="-fetch-data-protocol/-result/index.html"><span class="identifier">Result</span></a><span class="symbol">&lt;</span><span class="identifier">T</span><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code><p>An abstract protocol for fetching typed data from a remote peer.</p>
</td>
</tr>
<tr>
<td>
<a href="-fetch-transactions-protocol/index.html">FetchTransactionsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FetchTransactionsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-fetch-data-protocol/index.html"><span class="identifier">FetchDataProtocol</span></a><span class="symbol">&lt;</span><a href="../com.r3corda.core.contracts/-signed-transaction/index.html"><span class="identifier">SignedTransaction</span></a><span class="symbol">,</span>&nbsp;<a href="../com.r3corda.core.contracts/-signed-transaction/index.html"><span class="identifier">SignedTransaction</span></a><span class="symbol">&gt;</span></code><p>Given a set of tx hashes (IDs), either loads them from local disk or asks the remote peer to provide them.</p>
</td>
</tr>
<tr>
<td>
<a href="-finality-protocol/index.html">FinalityProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">FinalityProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">Unit</span><span class="symbol">&gt;</span></code><p>Finalise a transaction by notarising it, then recording it locally, and then sending it to all involved parties.</p>
</td>
</tr>
<tr>
<td>
<a href="-notary-change-protocol/index.html">NotaryChangeProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">NotaryChangeProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-abstract-state-replacement-protocol/index.html"><span class="identifier">AbstractStateReplacementProtocol</span></a><span class="symbol">&lt;</span><a href="../com.r3corda.core.crypto/-party/index.html"><span class="identifier">Party</span></a><span class="symbol">&gt;</span></code><p>A protocol to be used for changing a states Notary. This is required since all input states to a transaction
must point to the same notary.</p>
</td>
</tr>
<tr>
<td>
<a href="-notary-error/index.html">NotaryError</a></td>
<td>
<code><span class="keyword">sealed</span> <span class="keyword">class </span><span class="identifier">NotaryError</span></code></td>
</tr>
<tr>
<td>
<a href="-notary-protocol/index.html">NotaryProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">NotaryProtocol</span></code></td>
</tr>
<tr>
<td>
<a href="-party-request-message/index.html">PartyRequestMessage</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">PartyRequestMessage</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-service-request-message/index.html"><span class="identifier">ServiceRequestMessage</span></a></code></td>
</tr>
<tr>
<td>
<a href="-rates-fix-protocol/index.html">RatesFixProtocol</a></td>
<td>
<code><span class="keyword">open</span> <span class="keyword">class </span><span class="identifier">RatesFixProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">Unit</span><span class="symbol">&gt;</span></code><p>This protocol queries the given oracle for an interest rate fix, and if it is within the given tolerance embeds the
fix in the transaction and then proceeds to get the oracle to sign it. Although the <a href="-rates-fix-protocol/call.html">call</a> method combines the query
and signing step, you can run the steps individually by constructing this object and then using the public methods
for each step.</p>
</td>
</tr>
<tr>
<td>
<a href="-resolve-transactions-protocol/index.html">ResolveTransactionsProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ResolveTransactionsProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../com.r3corda.core.protocols/-protocol-logic/index.html"><span class="identifier">ProtocolLogic</span></a><span class="symbol">&lt;</span><span class="identifier">List</span><span class="symbol">&lt;</span><a href="../com.r3corda.core.contracts/-ledger-transaction/index.html"><span class="identifier">LedgerTransaction</span></a><span class="symbol">&gt;</span><span class="symbol">&gt;</span></code><p>This protocol is used to verify the validity of a transaction by recursively checking the validity of all the
dependencies. Once a transaction is checked its inserted into local storage so it can be relayed and wont be
checked again.</p>
</td>
</tr>
<tr>
<td>
<a href="-service-request-message/index.html">ServiceRequestMessage</a></td>
<td>
<code><span class="keyword">interface </span><span class="identifier">ServiceRequestMessage</span></code><p>Abstract superclass for request messages sent to services, which includes common
fields such as replyTo and sessionID.</p>
</td>
</tr>
<tr>
<td>
<a href="-state-replacement-refused/index.html">StateReplacementRefused</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">StateReplacementRefused</span></code><p>Thrown when a participant refuses the proposed state replacement</p>
</td>
</tr>
<tr>
<td>
<a href="-two-party-deal-protocol/index.html">TwoPartyDealProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">TwoPartyDealProtocol</span></code><p>Classes for manipulating a two party deal or agreement.</p>
</td>
</tr>
<tr>
<td>
<a href="-two-party-trade-protocol/index.html">TwoPartyTradeProtocol</a></td>
<td>
<code><span class="keyword">object </span><span class="identifier">TwoPartyTradeProtocol</span></code><p>This asset trading protocol implements a "delivery vs payment" type swap. It has two parties (B and S for buyer
and seller) and the following steps:</p>
</td>
</tr>
<tr>
<td>
<a href="-validating-notary-protocol/index.html">ValidatingNotaryProtocol</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">ValidatingNotaryProtocol</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="-notary-protocol/-service/index.html"><span class="identifier">Service</span></a></code><p>A notary commit protocol that makes sure a given transaction is valid before committing it. This does mean that the calling
party has to reveal the whole transaction history; however, we avoid complex conflict resolution logic where a party
has its input states "blocked" by a transaction from another party, and needs to establish whether that transaction was
indeed valid.</p>
</td>
</tr>
</tbody>
</table>
<h3>Exceptions</h3>
<table>
<tbody>
<tr>
<td>
<a href="-notary-exception/index.html">NotaryException</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">NotaryException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html"><span class="identifier">Exception</span></a></code></td>
</tr>
<tr>
<td>
<a href="-state-replacement-exception/index.html">StateReplacementException</a></td>
<td>
<code><span class="keyword">class </span><span class="identifier">StateReplacementException</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/lang/Exception.html"><span class="identifier">Exception</span></a></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
