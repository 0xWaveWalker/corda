<HTML>
<HEAD>
<title>ArtemisMessagingService - </title>
<link rel="stylesheet" href="../../style.css">
</HEAD>
<BODY>
<a href="../index.html">core.node.subsystems</a>&nbsp;/&nbsp;<a href=".">ArtemisMessagingService</a><br/>
<br/>
<h1>ArtemisMessagingService</h1>
<code><span class="keyword">class </span><span class="identifier">ArtemisMessagingService</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-messaging-service/index.html"><span class="identifier">MessagingService</span></a></code><br/>
<p>This class implements the <a href="../../core.messaging/-messaging-service/index.html">MessagingService</a> API using Apache Artemis, the successor to their ActiveMQ product.
Artemis is a message queue broker and here, we embed the entire server inside our own process. Nodes communicate
with each other using (by default) an Artemis specific protocol, but it supports other protocols like AQMP/1.0
as well.</p>
<p>The current implementation is skeletal and lacks features like security or firewall tunnelling (that is, you must
be able to receive TCP connections in order to receive messages). It is good enough for local communication within
a fully connected network, trusted network or on localhost.</p>
<br/>
<br/>
<h3>Parameters</h3>
<a name="directory"></a>
<code>directory</code> - A place where Artemis can stash its message journal and other files.<br/>
<br/>
<a name="myHostPort"></a>
<code>myHostPort</code> - What host and port to bind to for receiving inbound connections.<br/>
<br/>
<a name="defaultExecutor"></a>
<code>defaultExecutor</code> - This will be used as the default executor to run message handlers on, if no other is specified.<br/>
<br/>
<br/>
<h3>Types</h3>
<table>
<tbody>
<tr>
<td>
<a href="-handler/index.html">Handler</a></td>
<td>
<code><span class="keyword">inner</span> <span class="keyword">class </span><span class="identifier">Handler</span>&nbsp;<span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-message-handler-registration.html"><span class="identifier">MessageHandlerRegistration</span></a></code><p>A registration to handle messages of different types</p>
</td>
</tr>
</tbody>
</table>
<h3>Constructors</h3>
<table>
<tbody>
<tr>
<td>
<a href="-init-.html">&lt;init&gt;</a></td>
<td>
<code><span class="identifier">ArtemisMessagingService</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$<init>(java.nio.file.Path, , java.util.concurrent.Executor)/directory">directory</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/nio/file/Path.html"><span class="identifier">Path</span></a><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$<init>(java.nio.file.Path, , java.util.concurrent.Executor)/myHostPort">myHostPort</span><span class="symbol">:</span>&nbsp;<span class="identifier">&lt;ERROR CLASS&gt;</span><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$<init>(java.nio.file.Path, , java.util.concurrent.Executor)/defaultExecutor">defaultExecutor</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html"><span class="identifier">Executor</span></a>&nbsp;<span class="symbol">=</span>&nbsp;RunOnCallerThread<span class="symbol">)</span></code><p>This class implements the <a href="../../core.messaging/-messaging-service/index.html">MessagingService</a> API using Apache Artemis, the successor to their ActiveMQ product.
Artemis is a message queue broker and here, we embed the entire server inside our own process. Nodes communicate
with each other using (by default) an Artemis specific protocol, but it supports other protocols like AQMP/1.0
as well.</p>
</td>
</tr>
</tbody>
</table>
<h3>Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="default-executor.html">defaultExecutor</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">defaultExecutor</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html"><span class="identifier">Executor</span></a></code></td>
</tr>
<tr>
<td>
<a href="directory.html">directory</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">directory</span><span class="symbol">: </span><a href="http://docs.oracle.com/javase/6/docs/api/java/nio/file/Path.html"><span class="identifier">Path</span></a></code></td>
</tr>
<tr>
<td>
<a href="my-address.html">myAddress</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">myAddress</span><span class="symbol">: </span><a href="../../core.messaging/-single-message-recipient.html"><span class="identifier">SingleMessageRecipient</span></a></code><p>Returns an address that refers to this node.</p>
</td>
</tr>
<tr>
<td>
<a href="my-host-port.html">myHostPort</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">myHostPort</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="add-message-handler.html">addMessageHandler</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">addMessageHandler</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$addMessageHandler(kotlin.String, java.util.concurrent.Executor, kotlin.Function2((core.messaging.Message, core.messaging.MessageHandlerRegistration, kotlin.Unit)))/topic">topic</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$addMessageHandler(kotlin.String, java.util.concurrent.Executor, kotlin.Function2((core.messaging.Message, core.messaging.MessageHandlerRegistration, kotlin.Unit)))/executor">executor</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html"><span class="identifier">Executor</span></a><span class="symbol">?</span><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$addMessageHandler(kotlin.String, java.util.concurrent.Executor, kotlin.Function2((core.messaging.Message, core.messaging.MessageHandlerRegistration, kotlin.Unit)))/callback">callback</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><a href="../../core.messaging/-message/index.html"><span class="identifier">Message</span></a><span class="symbol">,</span>&nbsp;<a href="../../core.messaging/-message-handler-registration.html"><span class="identifier">MessageHandlerRegistration</span></a><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">Unit</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../core.messaging/-message-handler-registration.html"><span class="identifier">MessageHandlerRegistration</span></a></code><p>The provided function will be invoked for each received message whose topic matches the given string, on the given
executor. The topic can be the empty string to match all messages.</p>
</td>
</tr>
<tr>
<td>
<a href="create-message.html">createMessage</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">createMessage</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$createMessage(kotlin.String, kotlin.ByteArray)/topic">topic</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$createMessage(kotlin.String, kotlin.ByteArray)/data">data</span><span class="symbol">:</span>&nbsp;<span class="identifier">ByteArray</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../core.messaging/-message/index.html"><span class="identifier">Message</span></a></code><p>Returns an initialised <a href="../../core.messaging/-message/index.html">Message</a> with the current time, etc, already filled in.</p>
</td>
</tr>
<tr>
<td>
<a href="remove-message-handler.html">removeMessageHandler</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">removeMessageHandler</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$removeMessageHandler(core.messaging.MessageHandlerRegistration)/registration">registration</span><span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-message-handler-registration.html"><span class="identifier">MessageHandlerRegistration</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Removes a handler given the object returned from <a href="add-message-handler.html">addMessageHandler</a>. The callback will no longer be invoked once
this method has returned, although executions that are currently in flight will not be interrupted.</p>
</td>
</tr>
<tr>
<td>
<a href="send.html">send</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">send</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$send(core.messaging.Message, core.messaging.MessageRecipients)/message">message</span><span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-message/index.html"><span class="identifier">Message</span></a><span class="symbol">, </span><span class="identifier" id="node.services.messaging.ArtemisMessagingService$send(core.messaging.Message, core.messaging.MessageRecipients)/target">target</span><span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-message-recipients.html"><span class="identifier">MessageRecipients</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Sends a message to the given receiver. The details of how receivers are identified is up to the messaging
implementation: the type system provides an opaque high level view, with more fine grained control being
available via type casting. Once this function returns the message is queued for delivery but not necessarily
delivered: if the recipients are offline then the message could be queued hours or days later.</p>
</td>
</tr>
<tr>
<td>
<a href="start.html">start</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">start</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
<tr>
<td>
<a href="stop.html">stop</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">stop</span><span class="symbol">(</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
</tbody>
</table>
<h3>Companion Object Properties</h3>
<table>
<tbody>
<tr>
<td>
<a href="-t-o-p-i-c_-p-r-o-p-e-r-t-y.html">TOPIC_PROPERTY</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">TOPIC_PROPERTY</span><span class="symbol">: </span><span class="identifier">String</span></code></td>
</tr>
<tr>
<td>
<a href="log.html">log</a></td>
<td>
<code><span class="keyword">val </span><span class="identifier">log</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Companion Object Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="make-recipient.html">makeRecipient</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">makeRecipient</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService.Companion$makeRecipient()/hostAndPort">hostAndPort</span><span class="symbol">:</span>&nbsp;<span class="identifier">&lt;ERROR CLASS&gt;</span><span class="symbol">)</span><span class="symbol">: </span><a href="../../core.messaging/-single-message-recipient.html"><span class="identifier">SingleMessageRecipient</span></a></code><p>Temp helper until network map is established.</p>
<code><span class="keyword">fun </span><span class="identifier">makeRecipient</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService.Companion$makeRecipient(kotlin.String)/hostname">hostname</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
<tr>
<td>
<a href="to-host-and-port.html">toHostAndPort</a></td>
<td>
<code><span class="keyword">fun </span><span class="identifier">toHostAndPort</span><span class="symbol">(</span><span class="identifier" id="node.services.messaging.ArtemisMessagingService.Companion$toHostAndPort(kotlin.String)/hostname">hostname</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">&lt;ERROR CLASS&gt;</span></code></td>
</tr>
</tbody>
</table>
<h3>Extension Functions</h3>
<table>
<tbody>
<tr>
<td>
<a href="../../core.messaging/run-on-next-message.html">runOnNextMessage</a></td>
<td>
<code><span class="keyword">fun </span><a href="../../core.messaging/-messaging-service/index.html"><span class="identifier">MessagingService</span></a><span class="symbol">.</span><span class="identifier">runOnNextMessage</span><span class="symbol">(</span><span class="identifier" id="core.messaging$runOnNextMessage(core.messaging.MessagingService, kotlin.String, java.util.concurrent.Executor, kotlin.Function1((core.messaging.Message, kotlin.Unit)))/topic">topic</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span>&nbsp;<span class="symbol">=</span>&nbsp;""<span class="symbol">, </span><span class="identifier" id="core.messaging$runOnNextMessage(core.messaging.MessagingService, kotlin.String, java.util.concurrent.Executor, kotlin.Function1((core.messaging.Message, kotlin.Unit)))/executor">executor</span><span class="symbol">:</span>&nbsp;<a href="http://docs.oracle.com/javase/6/docs/api/java/util/concurrent/Executor.html"><span class="identifier">Executor</span></a><span class="symbol">?</span>&nbsp;<span class="symbol">=</span>&nbsp;null<span class="symbol">, </span><span class="identifier" id="core.messaging$runOnNextMessage(core.messaging.MessagingService, kotlin.String, java.util.concurrent.Executor, kotlin.Function1((core.messaging.Message, kotlin.Unit)))/callback">callback</span><span class="symbol">:</span>&nbsp;<span class="symbol">(</span><a href="../../core.messaging/-message/index.html"><span class="identifier">Message</span></a><span class="symbol">)</span>&nbsp;<span class="symbol">-&gt;</span>&nbsp;<span class="identifier">Unit</span><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code><p>Registers a handler for the given topic that runs the given callback with the message and then removes itself. This
is useful for one-shot handlers that arent supposed to stick around permanently. Note that this callback doesnt
take the registration object, unlike the callback to <a href="../../core.messaging/-messaging-service/add-message-handler.html">MessagingService.addMessageHandler</a>.</p>
</td>
</tr>
<tr>
<td>
<a href="../../core.messaging/send.html">send</a></td>
<td>
<code><span class="keyword">fun </span><a href="../../core.messaging/-messaging-service/index.html"><span class="identifier">MessagingService</span></a><span class="symbol">.</span><span class="identifier">send</span><span class="symbol">(</span><span class="identifier" id="core.messaging$send(core.messaging.MessagingService, kotlin.String, kotlin.Any, core.messaging.MessageRecipients)/topic">topic</span><span class="symbol">:</span>&nbsp;<span class="identifier">String</span><span class="symbol">, </span><span class="identifier" id="core.messaging$send(core.messaging.MessagingService, kotlin.String, kotlin.Any, core.messaging.MessageRecipients)/obj">obj</span><span class="symbol">:</span>&nbsp;<span class="identifier">Any</span><span class="symbol">, </span><span class="identifier" id="core.messaging$send(core.messaging.MessagingService, kotlin.String, kotlin.Any, core.messaging.MessageRecipients)/to">to</span><span class="symbol">:</span>&nbsp;<a href="../../core.messaging/-message-recipients.html"><span class="identifier">MessageRecipients</span></a><span class="symbol">)</span><span class="symbol">: </span><span class="identifier">Unit</span></code></td>
</tr>
</tbody>
</table>
</BODY>
</HTML>
