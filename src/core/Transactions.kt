package core

import java.time.Instant

// Various views of transactions as they progress through the pipeline:
//
// TimestampedWireTransaction(WireTransaction) -> LedgerTransaction -> TransactionForVerification
//                                                                     TransactionForTest

class WireTransaction(
    // TODO: This is supposed to be a protocol buffer, FIX SPE message, etc. For prototype it can just be Kryo serialised.
    val tx: ByteArray,

    // We assume Ed25519 signatures for all. Num signatures == array.length / 64 (each sig is 64 bytes in size)
    // This array is in the same order as the public keys in the commands array, so signatures can be matched to
    // public keys in that manner.
    val signatures: ByteArray
)

class TimestampedWireTransaction(
    // A serialised WireTransaction
    val wireTX: ByteArray,

    // This is, for example, an RFC 3161 serialised structure (but we probably want something more compact).
    val timestamp: ByteArray
)

/**
 * A LedgerTransaction wraps the data needed to calculate one or more successor states from a set of input states.
 * It is the first step after extraction from a WireTransaction. The signature part is tricky.
 */
class LedgerTransaction(
    /** The input states which will be consumed/invalidated by the execution of this transaction. */
    val inputStates: List<ContractStateRef>,
    /** The states that will be generated by the execution of this transaction. */
    val outputStates: List<ContractState>,
    /** Arbitrary data passed to the program of each input state. */
    val args: List<SignedCommand>,
    /** The moment the transaction was timestamped for */
    val time: Instant

    // TODO: nLockTime equivalent?
)

/** A transaction in fully resolved form, ready for passing as input to a verification function */
class TransactionForVerification(
    val inStates: List<ContractState>,
    val outStates: List<ContractState>,
    val args: List<VerifiedSigned<Command>>,
    val time: Instant
) {
    fun verify(programMap: Map<SecureHash, Contract>) {
        // For each input and output state, locate the program to run. Then execute the verification function. If any
        // throws an exception, the entire transaction is invalid.
        val programHashes = (inStates.map { it.programRef } + outStates.map { it.programRef }).toSet()
        for (hash in programHashes) {
            val program = programMap[hash] ?: throw IllegalStateException("Unknown program hash $hash")
            program.verify(this)
        }
    }
}