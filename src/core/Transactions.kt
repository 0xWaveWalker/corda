package core

import java.time.Instant

// Various views of transactions as they progress through the pipeline:
//
// WireTransaction -> LedgerTransaction -> TransactionForVerification
//                                         TransactionForTest

class WireTransaction(
    // TODO: This is supposed to be a protocol buffer, FIX SPE message, etc. For prototype it can just be Kryo serialised.
    val tx: ByteArray,

    // We assume Ed25519 signatures for all. Num signatures == array.length / 64 (each sig is 64 bytes in size)
    val signatures: ByteArray
)

/**
 * A LedgerTransaction wraps the data needed to calculate one or more successor states from a set of input states.
 * It is the first step after extraction from a WireTransaction. The signature part is tricky.
 */
class LedgerTransaction(
    /** The input states which will be consumed/invalidated by the execution of this transaction. */
    val inputStates: List<ContractStateRef>,
    /** The states that will be generated by the execution of this transaction. */
    val outputStates: List<ContractState>,
    /** Arbitrary data passed to the program of each input state. */
    val args: List<SignedCommand>,
    /** The moment the transaction was timestamped for */
    val time: Instant
)

/** A transaction in fully resolved form, ready for passing as input to a verification function */
class TransactionForVerification(
    val inStates: List<ContractState>,
    val outStates: List<ContractState>,
    val args: List<VerifiedSigned<Command>>,
    val time: Instant
) {

    fun verify(programMap: Map<SecureHash, Contract>) {
        // For each input and output state, locate the program to run. Then execute the verification function. If any
        // throws an exception, the entire transaction is invalid.
        fun runContracts(desc: String, l: List<ContractState>) {
            for ((index, state) in l.withIndex()) {
                val contract = programMap[state.programRef] ?: throw IllegalStateException("$desc state $index refers to unknown contract ${state.programRef}")
                contract.verify(this)
            }
        }

        runContracts("input", inStates)
        runContracts("output", outStates)
    }
}